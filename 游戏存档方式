1）PlayerPrefs
2)C#序列化
3）xml序列化
4）Json


首先，使用PlayerPrefs会遇到很多的限制。

所以，积极采取其他三种。

c#序列化
优点：除了静态类型和抽象类型以及类必须标记为[Serializable]的（其实这个不是什么问题了），其他的都可以被序列化：类，数组，集合，字典，类及其子类等。而且序列化之后你也看不懂是什么鬼（哈哈）~~。

缺点： 
1.不会调用要序列化类的构造函数（当然可以通过实现ISerializable和IDeserializationCallback接口来实现在序列化和反序列化之前对数据的处理，所以这个不是我放弃它的重点）。 
2.在升级版本后，新增一个字段也只是采用系统默认值，而不是我在类中直接赋的值，这导致我需要自己去比较当前版本和之前的每一个版本的版本号，然后再挨个处理每个以前版本的升级，就意味着当前是第N次更新，我要做N-1次if判断并手动赋值（这段话是结合自己的项目记录的，当然也就我看得懂了^^）。 
3.而让我放弃它的最终原因是，在升级版本后，如果删除了之前的一个字段，则无法正确解析（反序列化），这种情况就最不能容忍了。我不敢冒这样的风险，保证以后的版本不会删除其中一个字段。或许你会想到“你可以保留啊，然后不管它就是了”，不过鉴于我有个超追求完美的boss，只好放弃。毕竟这还不如XML。

XML序列化
优点： 1.序列化出来的数据直观，可以序列化类和类中的对象。 2.升级版本后，如果新增了字段，则自动采用你在类中赋给该变量的值。 3.升级版本后，如果删除了之前的字段，则自动忽略之前的字段，而不会像c#序列化一样报错，

缺点： 1.不能序列化字典，二维数组以上的数据 2.比Json更占空间，且引入的dll也更大。

Json(LitJson)
优点： 1.简单轻量 2.可以满足你要序列化的几乎任何类型数据（除了float必须用double来存） 3.如果要升级版本，可以任意删除之前的字段而不会出现不能解析的情况；可以新增字段且采用你在类中直接赋的值（不用像c#序列化那样手动赋值了）。

缺点： 1.相对PlayerPrefs来说，引入了一个50kb左右的dll。 2.不能序列化float类型。3.不支持更改字段名。如果更改了，就相当于是两个操作，即删除之前的并新增加一个（这一点很重要）。





